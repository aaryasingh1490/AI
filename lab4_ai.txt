# Install and import necessary libraries
import numpy as np
import pandas as pd
import networkx as nx  # for graph representation of the decision tree
import matplotlib.pyplot as plt

# Define the A* Algorithm class
class AStar:
    def __init__(self, graph, start_node, heuristics):
        self.graph = graph
        self.start_node = start_node
        self.heuristics = heuristics  # Heuristic values for each node
        self.solution_graph = {}  # Store the optimal solution path

    def expand_node(self, node):
        """ Expand a node by considering all children (AND/OR nodes) """ 
        if node not in self.graph:
            return []
        children = self.graph[node]
        return children

    def compute_and_or_cost(self, node, children):
        """ Calculate cost for AND/OR nodes based on children' nodes' cost """
        if children is None:
            return float('inf')

        and_cost = sum(self.heuristics[child] for child in children)
        or_cost = min(self.heuristics[child] for child in children)

        return min(and_cost, or_cost)  # the lower of AND/OR costs to select optimal path

    def update_heuristics(self, node):
        """ Update node's heuristic values based on computed AND-OR costs """ 
        if node in self.graph:
            children = self.expand_node(node)
            self.heuristics[node] = self.compute_and_or_cost(node, children)

    def do_a_star_search(self, node):
        """ Implement A* heuristic search algorithm to find optimal solution path """ 
        # If node has no children, return its heuristic as cost
        if len(node) == 0:
            return self.heuristics[node]
        if node not in self.graph:
            return float('inf')

        # Explore each child node and recursively apply A* search
        for child in self.expand_node(node):
            self.update_heuristics(child)
            self.do_a_star_search(child)

        # Update solution graph for optimal path tracking
        self.solution_graph[node] = self.graph[node]
        return self.heuristics[node]

# Initialize Graph with Threats and Response Actions
graph = {
    'Start': ['Identify Threat', 'Evaluate Impact'],
    'Identify Threat': ['Analyze Traffic', 'Scan Logs'],
    'Evaluate Impact': None,  # Need node, mitigation ends here
    'Analyze Traffic': None,  # Need node, mitigation ends here
    'Scan Logs': None,  # Leaf node, no further actions
    'High Impact': None,  # Leaf node, no further actions
    'Mitigate Attack': None,
    'Isolate System': None,
}

# Define Heuristic Values for Each Node (Assume some initial values)
heuristics = {
    'Start': 5,
    'Identify Threat': 3,
    'Evaluate Impact': 3,
    'Analyze Traffic': 2,
    'Scan Logs': 1,
    'High Impact': 2,
    'Mitigate Attack': 1,
    'Isolate System': 2,
}

# Initialize A* Algorithm and Run Search
ao_star_data = aosat(graph=graph, start_node='Start', heuristics=heuristics)
optimal_solution_path = ao_star.a_star_search('Start')

print("Optimal Solution Path:", optimal_solution_path)
print("Heuristic values seen A* Search:", ao_star.heuristics)
print("Optimal cost from Start:", optimal_cost)

# Initialize A* Algorithm and Run Search
    ao_star = A_star(graph=graph, start_node='Start', heuristics=heuristics)
    optimal_cost = ao_star.a_star_search('Start')

# Print Optimal Solution Path and Heuristic Values
    print("Optimal Solution Path:")
    print(ao_star.solution_graph)
    print("Heuristic Values after A* Search:")
    print(ao_star.heuristics)
    print("Optimal cost from 'Start':", optimal_cost)

# Enhanced Visualization of the Decision Tree with Optimal Path Highlighted

def visualize_graph(graph, solution_graph, heuristics):
    # Create a directed graph for visualization
    g = nx.DiGraph()

    # Add edges to the graph based on the structure of the decision tree
    for node, children in graph.items():
        g.add_edge(node, children)
        for child in children:
            g.add_edge(node, child)

    # Define node colors based on whether they're in the optimal path
    node_colors = ["lightgreen" if node in solution_graph else "lightblue" for node in g.nodes()]
    
    # Define labels with heuristic values for clearer understanding
    node_labels = {node: f"{node}\n({heuristics[node]})" for node in g.nodes()}

    # Define layout for visualization
    pos = nx.spring_layout(g, seed=42)  # Set seed for consistent layout
    
    node_size = 800
    alpha = 0.9
    nx.draw(g, pos, node_color=node_colors, node_size=node_size, alpha=alpha)
    nx.draw_networkx_edges(g, pos, edge_color="gray", alpha=0.5)
    nx.draw_networkx_labels(g, pos, labels=node_labels, font_size=10, font_weight="bold")

    edge_labels = {(node, child): "" for node in solution_graph for child in graph[node]}
    nx.draw_networkx_edge_labels(g, pos, edge_labels=edge_labels, font_size=8)

    plt.title("Decision Tree Visualization with A* Optimal Path Highlighted")
    plt.axis("off")  # Hide axis for a cleaner look
    plt.show()

# Run visualization function
    visualize_graph(graph, a_star_solution_graph, a_star_heuristics)